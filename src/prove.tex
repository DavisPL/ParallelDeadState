
\begin{algorithm}[H]
    \caption{Parallel Dead-state Detection}
    \KwIn{$G \mbox{ the original graph}, G^*=(V^*, E^*) \mbox{ the new inserted edges and vertices}, \overline V \mbox{ the closed vertices}$}
    $\mbox{UF: a union-find data structure over }V$ \\
    $\mbox{EF: a union-find datastructure providing path to living verticies}$ \\
    \KwOut{A set of dead states}
    \SetKwFor{parForEach}{ParallelForEach}{do}{endfor}
    \parForEach{$e=(u,v)\in E^*$}{
        $x \gets UF.find(u), y\gets UF.find(v)$
        \If {$Status(x) \neq Live$} {
            $\mbox{append } (u,v) \mbox{ to } res(x)$ \\
            $\mbox{append } (u,v) \mbox{ to } bck(y)$
        }
    }
    \parForEach {$v\in V$}{
        $p\gets EF.find(u)$ \\
        \If{$p \in \overline V$} {add $v$ to $\overline V$, $EF.setsucc{v,v}$}
    }
    \parForEach{$v\in \overline V$}{
        set $v$'s priority as a random value\\
        $y \gets UF.find(v)$
        \If{$status(y) \neq Open$}{set $v$'s priority to $0$;Return}
        \While{$res(y) \neq \emptyset$}{
            $pop (v,w) $ from $res(y)$; \\ % TODO: we should maintain the top edge be the edge in EF for v as well
            $z\gets UF.find(w)$ \\
            \While{$z$ has higher priority} {}
            \If{$status(z) = Dead$} {continue}
            \eIf{$EF.connected(u,v)$}{$merge(y,z)$}{
                $status(y) \gets unknown; succ(y) \gets z$ \\
                $EF.add(v,w)$; set $v$'s priority to $0$, return;
            }
        }
        $status(y) \gets Dead$, set $v$'s priority to $0$.
    }
    \parForEach{$v\in V$}{
        \If{$status(UF.ancestor(y))$}{
            output $v$ is dead.
        }
    }
    \label{alg:parallel_dead_state_detection}
\end{algorithm}
\section{Parallel Dead-state Detection}
Dead states occur when certain vertices in a graph cannot reach any living vertices, indicating that they are effectively "dead" in terms of computation. In \ref{cav2023Inc} we have introduced a sequential lograthmic algorithm for dead state detection with certain input, and here we present a parallel algorithm for the same problem. The parallel algorithm is based on the sequential algorithm, and we will first introduce the sequential algorithm and then present the parallel algorithm.

\subsection{Problem description}
An incremental digraph is a sequence of directed graphs $G_0, G_1, \ldots, G_t$ where each $G_i$ is obtained from $G_{i-1}$ by adding a batch $\{\overline V, \overline E\}$ of new vertices and some edges. In a \textsl{guided} incremental graph, we also include updates $C(u)$ labeling a state as \textsl{closed}, meaning that they will not receive any further outgoing edges.

\begin{definition}
    Define a \textsl{guided batch incremental digraph} to be a sequence of updates, where each update contains such a batch $\{\overline V, \overline E\}$ and a set of closed vertices $\overline C$.

    \begin{enumerate}
        \item a set of new directed edge $\overline E$.
        \item a set of vertex $T(u)$ indicating each u is \textsl{terminal}.
        \item a set of label $C(u)$ indicating each u is \textsl{closed}.
    \end{enumerate}
\end{definition}

\begin{table}
    \begin{tabular}{l|l}
        \hline
        Live & Some reachable state from $u$ is terminal. \\
        Dead & All reachable state from $u$ are closed and not terminal. \\
        Unknown & $u$ is closed but not live or dead. \\
        Open & $u$ is not live and not closed. \\
        \hline
    \end{tabular}
    \caption{Status of a vertex}
    \label{tab:status}
\end{table}